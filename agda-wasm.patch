diff --git a/Agda.cabal b/Agda.cabal
index 83235557e1..0aeb0c28b4 100644
--- a/Agda.cabal
+++ b/Agda.cabal
@@ -517,7 +517,6 @@ library
     , enummapset           >= 0.6.0.3   && < 0.8
     , equivalence          >= 0.3.5     && < 0.5
     , exceptions           >= 0.10.4    && < 0.11
-    , filelock             >= 0.1.1.5   && < 0.2
     , filepath             >= 1.4.2.1   && < 1.6
     , filemanip            >= 0.3.6.3   && < 0.4
     , generic-data         >= 0.9.2.0   && < 1.2
@@ -552,6 +551,14 @@ library
     , vector-hashtables    >= 0.1.1.1   && < 0.2
     , zlib                 >= 0.6.2.2   && < 0.8
 
+  if arch(wasm32)
+    build-depends:
+      , unix-compat        >= 0.4.3.1   && < 0.8
+      , unix               >= 2.8.0.0   && < 2.9
+  else
+    build-depends:
+      , filelock           >= 0.1.1.5   && < 0.2
+
   -- We don't write upper bounds for Alex nor Happy because the
   -- `build-tool-depends` field can not be modified in Hackage.
   build-tool-depends:
@@ -647,6 +654,7 @@ library
       Agda.Setup
       Agda.Setup.DataFiles
       Agda.Setup.EmacsMode
+      Agda.Setup.LockFile
       Agda.Syntax.Abstract.Name
       Agda.Syntax.Abstract.Pattern
       Agda.Syntax.Abstract.PatternSynonyms
@@ -980,10 +988,12 @@ executable agda
   -- been idle for 0.3Â s. This feature turned out to be annoying, so
   -- the idle GC is now by default turned off (-I0).
   ghc-options:
-    -threaded
     -rtsopts
     -with-rtsopts=-I0
 
+  if !arch(wasm32)
+    ghc-options: -threaded
+
 -- agda-mode executable
 ---------------------------------------------------------------------------
 
@@ -999,6 +1009,7 @@ executable agda-mode
     Agda.Setup
     Agda.Setup.DataFiles
     Agda.Setup.EmacsMode
+    Agda.Setup.LockFile
     Agda.Version
     Agda.VersionCommit
 
@@ -1014,12 +1025,15 @@ executable agda-mode
     , base                 >= 4.13.0.0  && < 4.22
     , bytestring           >= 0.10.10.1 && < 0.13
     , directory            >= 1.3.6.0   && < 1.4
-    , filelock             >= 0.1.1.5   && < 0.2
     , filepath             >= 1.4.2.1   && < 1.6
     , gitrev               >= 1.3.1     && < 2
     , process              >= 1.6.9.0   && < 1.7
     , template-haskell     >= 2.15.0.0  && < 2.24
 
+  if !arch(wasm32)
+    build-depends:
+      , filelock           >= 0.1.1.5   && < 0.2
+
 -- Cabal testsuite integration has some serious bugs, but we
 -- can still make it work. See also:
 -- https://github.com/haskell/cabal/issues/1938
diff --git a/src/full/Agda/Interaction/AgdaTop.hs b/src/full/Agda/Interaction/AgdaTop.hs
index 5bdfedf961..a1dc8edb1e 100644
--- a/src/full/Agda/Interaction/AgdaTop.hs
+++ b/src/full/Agda/Interaction/AgdaTop.hs
@@ -1,4 +1,5 @@
 {-# OPTIONS_GHC -Wunused-imports #-}
+{-# Language CPP #-}
 
 module Agda.Interaction.AgdaTop
     ( repl
@@ -20,6 +21,11 @@ import Agda.Interaction.InteractionTop
 import Agda.Interaction.Options
 import Agda.Interaction.Command ( CommandM )
 
+#if defined(wasm32_HOST_ARCH)
+import Agda.Utils.IO                ( catchIO )
+import System.Posix.IO              ( stdInput, setFdOption, FdOption(..) )
+#endif
+
 import Agda.TypeChecking.Monad
 import qualified Agda.TypeChecking.Monad.Benchmark as Bench
 
@@ -28,6 +34,12 @@ import qualified Agda.TypeChecking.Monad.Benchmark as Bench
 -- | 'repl' is a fake ghci interpreter for both the Emacs the JSON frontend
 repl :: InteractionOutputCallback -> String -> TCM () -> TCM ()
 repl callback prompt setup = do
+
+#if defined(wasm32_HOST_ARCH)
+    liftIO $ setFdOption stdInput NonBlockingRead True
+      `catchIO` (\ (e :: IOError) -> hPutStrLn stderr $ "Failed to enable nonblocking on stdin: " ++ (show e) ++ "\nThe WASM module might not behave correctly.")
+#endif
+
     liftIO $ do
       hSetBuffering stdout LineBuffering
       hSetBuffering stdin  LineBuffering
diff --git a/src/setup/Agda/Setup.hs b/src/setup/Agda/Setup.hs
index a5bcbfbd8f..6cf0882e9e 100644
--- a/src/setup/Agda/Setup.hs
+++ b/src/setup/Agda/Setup.hs
@@ -1,5 +1,6 @@
 {-# LANGUAGE CPP #-}
 {-# LANGUAGE TemplateHaskell #-}
+{-# OPTIONS_GHC -Wunused-imports #-}
 
 -- | Agda's self-setup.
 
@@ -11,8 +12,7 @@ module Agda.Setup
   )
 where
 
-import           Control.Exception          ( IOException, try )
-import           Control.Monad              ( forM, forM_, unless, void, when )
+import           Control.Monad              ( forM_, unless, when )
 
 import           Data.ByteString            ( ByteString )
 import qualified Data.ByteString            as BS
@@ -29,14 +29,14 @@ import           Instances.TH.Lift          ()
 import           System.Directory
   ( XdgDirectory (..)
   , canonicalizePath, createDirectoryIfMissing, doesDirectoryExist
-  , getAppUserDataDirectory, getXdgDirectory, removeFile
+  , getAppUserDataDirectory, getXdgDirectory 
   )
 import           System.Environment         ( lookupEnv )
-import           System.FileLock            ( pattern Exclusive, withFileLock )
-import           System.FilePath            ( (</>), joinPath, splitFileName, takeFileName )
+import           System.FilePath            ( (</>), splitFileName )
 import           System.IO                  ( hPutStrLn, stderr )
 
 import           Agda.Setup.DataFiles       ( dataFiles, dataPath )
+import           Agda.Setup.LockFile        ( withLockFile )
 import           Agda.VersionCommit         ( versionWithCommitInfo )
 
 import qualified Paths_Agda                 as Paths
@@ -150,8 +150,7 @@ dumpDataDir verbose baseDataDir = do
   -- Create a file lock to prevent races caused by the dataDir already created
   -- but not filled with its contents.
   let lock = baseDataDir </> intercalate "-" [".lock", versionWithCommitInfo]
-  withFileLock lock Exclusive \ _lock -> do
-
+  withLockFile lock do
     forM_ embeddedDataDir \ (relativePath, content) -> do
 
       -- Make sure we also create the directories along the way.
@@ -164,10 +163,6 @@ dumpDataDir verbose baseDataDir = do
       when verbose $ inform $ "Writing " ++ path
       BS.writeFile path content
 
-  -- Remove the lock (this is surprisingly not done by withFileLock).
-  -- Ignore any IOException (e.g. if the file does not exist).
-  void $ try @IOException $ removeFile lock
-
 -- | Dump line of warning or information to stderr.
 inform :: String -> IO ()
 inform = hPutStrLn stderr
diff --git a/src/setup/Agda/Setup/LockFile.hs b/src/setup/Agda/Setup/LockFile.hs
new file mode 100644
index 0000000000..662f3b327d
--- /dev/null
+++ b/src/setup/Agda/Setup/LockFile.hs
@@ -0,0 +1,52 @@
+{-# LANGUAGE CPP #-}
+{-# OPTIONS_GHC -Wunused-imports #-}
+
+module Agda.Setup.LockFile ( withLockFile ) where
+
+import           Control.Exception          ( IOException, finally, try )
+
+import           System.Directory           ( removeFile )
+
+#ifdef wasm32_HOST_ARCH
+import           Control.Concurrent         ( threadDelay )
+
+import           Data.Bits                  ( (.|.) )
+
+import           System.Posix.Internals     ( c_open, c_close, o_CREAT, o_EXCL, o_WRONLY, withFilePath )
+import           Foreign.C                  ( eEXIST, eINTR, getErrno, throwErrno )
+#else
+import           System.FileLock            ( pattern Exclusive, withFileLock )
+#endif
+
+
+-- | Run an action with an exclusive lock over the given path
+withLockFile :: FilePath -> IO a -> IO a
+
+#ifdef wasm32_HOST_ARCH
+withLockFile path go =
+  withFilePath path (worker baseDelay)
+  -- Remove the lock file afterwards. Ignore any IOException (e.g. if the file
+  -- does not exist).
+  `finally` try @IOException (removeFile path)
+
+  where
+    baseDelay = 50000 -- 50ms
+    maxDelay = 1000000 -- 1s
+
+    -- Attempt to create our lock file, retrying until we succeed.
+    worker delay cpath = do
+      fd <- c_open cpath (o_CREAT .|. o_EXCL .|. o_WRONLY) 0o600
+      if fd /= (-1) then c_close fd >> go
+      else do
+        error <- getErrno
+        if error == eEXIST then threadDelay delay >> worker (min (delay * 2) maxDelay) cpath
+        else if error == eINTR then worker delay cpath
+        else throwErrno ("withLockFile: " ++ path)
+
+#else
+withLockFile path go =
+  withFileLock path Exclusive (const go)
+  -- Remove the lock (this is surprisingly not done by withFileLock).
+  -- Ignore any IOException (e.g. if the file does not exist).
+  `finally` try @IOException (removeFile path)
+#endif
